# Package Manager Detection

Smart-run automatically detects your package manager using a sophisticated priority system that ensures compatibility with various project setups while respecting your existing configuration.

## Detection Priority

Smart-run uses the following priority system to determine which package manager to use:

1. **ntl.runner** configuration in package.json
2. **packageManager** field in package.json (npm/yarn/pnpm standard)
3. **Lock file detection** (pnpm-lock.yaml, bun.lockb, yarn.lock)
4. **NTL_RUNNER** environment variable
5. **npm** as default fallback

## Detection Methods

### Method 1: ntl.runner Configuration

Configure the package manager directly in your package.json:

```json
{
  "scripts": { "start": "server.js" },
  "ntl": {
    "runner": "pnpm"
  }
}
```

This method has the highest priority and will override all other detection methods.

### Method 2: packageManager Field

Use the standard packageManager field (supported by npm, yarn, pnpm):

```json
{
  "scripts": { "start": "server.js" },
  "packageManager": "yarn@3.2.1"
}
```

Smart-run will parse this field and extract the package manager name.

### Method 3: Lock File Detection

Smart-run automatically detects your package manager based on lock files in your project:

- `pnpm-lock.yaml` â†’ uses pnpm
- `bun.lockb` â†’ uses bun  
- `yarn.lock` â†’ uses yarn
- `package-lock.json` â†’ uses npm

This method is very reliable as lock files are automatically generated by package managers.

### Method 4: Environment Variable

Set the NTL_RUNNER environment variable:

```bash
export NTL_RUNNER=pnpm
smart-run
```

This is useful for CI/CD environments or when you want to temporarily override the detected package manager.

### Method 5: Default Fallback

If none of the above methods detect a package manager, smart-run defaults to `npm`.

## Supported Package Managers

Smart-run supports all major package managers:

- **npm** - The default Node.js package manager
- **yarn** - Fast, reliable, and secure dependency management
- **pnpm** - Fast, disk space efficient package manager
- **bun** - All-in-one JavaScript runtime & toolkit

## Command Generation

Once detected, smart-run generates the appropriate commands for each package manager:

| Package Manager | Command Format |
|----------------|----------------|
| npm            | `npm run <script>` |
| yarn           | `yarn <script>` |
| pnpm           | `pnpm run <script>` |
| bun            | `bun run <script>` |

## Detection Output

When you run smart-run, it will display the detected package manager:

```bash
$ smart-run
ðŸ“¦ Detected package manager: pnpm
   (configured via ntl.runner)
```

The output shows both the detected package manager and the detection method used.

## Best Practices

### For Individual Projects

1. **Use packageManager field** for explicit configuration
2. **Let lock files handle detection** for most cases
3. **Use ntl.runner** only if you need ntl compatibility

### For Teams

1. **Document your choice** in project README
2. **Use packageManager field** for consistency
3. **Include lock files** in version control

### For CI/CD

1. **Set NTL_RUNNER** environment variable if needed
2. **Ensure lock files are available** in the build environment
3. **Use explicit configuration** to avoid detection issues

## Troubleshooting

### Wrong Package Manager Detected

If smart-run detects the wrong package manager:

1. Check for conflicting lock files
2. Set the packageManager field explicitly
3. Use the NTL_RUNNER environment variable as override

### Package Manager Not Found

If the detected package manager is not installed:

1. Install the required package manager
2. Use NTL_RUNNER to override to an installed one
3. Remove conflicting lock files

### Multiple Lock Files

If you have multiple lock files (e.g., both yarn.lock and package-lock.json):

1. Remove the unused lock file
2. Set packageManager field explicitly
3. Use ntl.runner configuration for explicit control

This detection system ensures smart-run works seamlessly with your existing project setup while providing multiple ways to override the detection when needed. 