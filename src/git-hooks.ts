import { execSync } from 'node:child_process';
import fs from 'node:fs';
import path from 'node:path';

type HookResult = {
  hook: string;
  success: boolean;
  message: string;
};

type HookStatus = {
  exists: boolean;
  isSmartRunHook: boolean;
  executable: boolean;
};

type HookManager = {
  name: string;
  detected: boolean;
  configFile: string;
  integration: string;
};

type IntegrationInstruction = {
  title: string;
  steps: string[];
};

type InstallOptions = {
  hooks?: string[];
  force?: boolean;
};

type UninstallOptions = {
  hooks?: string[];
};

/**
 * Git hooks integration for smart-run configuration linting
 */
class GitHooks {
  private hooksDir: string;
  private supportedHooks: string[];

  constructor() {
    this.hooksDir = '.git/hooks';
    this.supportedHooks = ['pre-commit', 'pre-push', 'commit-msg'];
  }

  /**
   * Install git hooks for configuration linting
   */
  install(options: InstallOptions = {}): HookResult[] {
    const { hooks = ['pre-commit'], force = false } = options;

    if (!this.isGitRepository()) {
      throw new Error('Not a git repository');
    }

    this.ensureHooksDirectory();

    const results: HookResult[] = [];

    hooks.forEach((hookName) => {
      if (!this.supportedHooks.includes(hookName)) {
        results.push({ hook: hookName, success: false, message: 'Unsupported hook type' });
        return;
      }

      try {
        this.installHook(hookName, force);
        results.push({ hook: hookName, success: true, message: 'Installed successfully' });
      } catch (error) {
        results.push({ hook: hookName, success: false, message: (error as Error).message });
      }
    });

    return results;
  }

  /**
   * Uninstall git hooks
   */
  uninstall(options: UninstallOptions = {}): HookResult[] {
    const { hooks = ['pre-commit'] } = options;

    const results: HookResult[] = [];

    hooks.forEach((hookName) => {
      try {
        this.uninstallHook(hookName);
        results.push({ hook: hookName, success: true, message: 'Uninstalled successfully' });
      } catch (error) {
        results.push({ hook: hookName, success: false, message: (error as Error).message });
      }
    });

    return results;
  }

  /**
   * Check if hooks are installed
   */
  status(): Record<string, HookStatus> {
    const status: Record<string, HookStatus> = {};

    this.supportedHooks.forEach((hookName) => {
      const hookPath = path.join(this.hooksDir, hookName);
      const exists = fs.existsSync(hookPath);

      if (exists) {
        const content = fs.readFileSync(hookPath, 'utf8');
        const isSmartRunHook = content.includes('smart-run-config-lint');
        status[hookName] = {
          exists: true,
          isSmartRunHook,
          executable: this.isExecutable(hookPath),
        };
      } else {
        status[hookName] = {
          exists: false,
          isSmartRunHook: false,
          executable: false,
        };
      }
    });

    return status;
  }

  /**
   * Install a specific hook
   */
  installHook(hookName: string, force: boolean = false): void {
    const hookPath = path.join(this.hooksDir, hookName);

    // Check if hook already exists
    if (fs.existsSync(hookPath) && !force) {
      const content = fs.readFileSync(hookPath, 'utf8');
      if (content.includes('smart-run-config-lint')) {
        throw new Error('Smart-run hook already installed');
      } else {
        throw new Error('Hook already exists (use --force to overwrite)');
      }
    }

    const hookContent = this.generateHookContent(hookName);
    fs.writeFileSync(hookPath, hookContent, { mode: 0o755 });
  }

  /**
   * Uninstall a specific hook
   */
  uninstallHook(hookName: string): void {
    const hookPath = path.join(this.hooksDir, hookName);

    if (!fs.existsSync(hookPath)) {
      throw new Error('Hook not found');
    }

    const content = fs.readFileSync(hookPath, 'utf8');
    if (!content.includes('smart-run-config-lint')) {
      throw new Error('Not a smart-run hook');
    }

    fs.unlinkSync(hookPath);
  }

  /**
   * Generate hook content based on hook type
   */
  generateHookContent(hookName: string): string {
    const nodeExecutable = process.execPath;
    const smartRunLinter = path.resolve(__dirname, 'config-linter.js');

    const baseContent = `#!/bin/sh
# Smart-run configuration linter hook
# Generated by smart-run git hooks integration

# smart-run-config-lint marker (do not remove)
`;

    switch (hookName) {
      case 'pre-commit':
        return (
          baseContent +
          `
# Check if package-meta.yaml exists and lint it
if [ -f "package-meta.yaml" ]; then
  echo "ðŸ” Linting smart-run configuration..."
  "${nodeExecutable}" "${smartRunLinter}"
  
  if [ $? -ne 0 ]; then
    echo "âŒ Configuration linting failed. Please fix issues before committing."
    echo "ðŸ’¡ Run 'npx smart-run lint' to see detailed issues."
    exit 1
  fi
  
  echo "âœ… Configuration linting passed!"
fi
`
        );

      case 'pre-push':
        return (
          baseContent +
          `
# Check if package-meta.yaml exists and lint it before push
if [ -f "package-meta.yaml" ]; then
  echo "ðŸ” Linting smart-run configuration before push..."
  "${nodeExecutable}" "${smartRunLinter}"
  
  if [ $? -ne 0 ]; then
    echo "âŒ Configuration linting failed. Please fix issues before pushing."
    echo "ðŸ’¡ Run 'npx smart-run lint' to see detailed issues."
    exit 1
  fi
  
  echo "âœ… Configuration linting passed!"
fi
`
        );

      case 'commit-msg':
        return (
          baseContent +
          `
# Check if package-meta.yaml exists and lint it on commit message
if [ -f "package-meta.yaml" ]; then
  echo "ðŸ” Linting smart-run configuration..."
  "${nodeExecutable}" "${smartRunLinter}"
  
  if [ $? -ne 0 ]; then
    echo "âŒ Configuration linting failed. Please fix issues before committing."
    echo "ðŸ’¡ Run 'npx smart-run lint' to see detailed issues."
    exit 1
  fi
fi
`
        );

      default:
        throw new Error(`Unsupported hook: ${hookName}`);
    }
  }

  /**
   * Check if current directory is a git repository
   */
  isGitRepository(): boolean {
    try {
      execSync('git rev-parse --git-dir', { stdio: 'ignore' });
      return true;
    } catch (_error) {
      return false;
    }
  }

  /**
   * Ensure hooks directory exists
   */
  ensureHooksDirectory(): void {
    if (!fs.existsSync(this.hooksDir)) {
      fs.mkdirSync(this.hooksDir, { recursive: true });
    }
  }

  /**
   * Check if file is executable
   */
  isExecutable(filePath: string): boolean {
    try {
      const stats = fs.statSync(filePath);
      return (stats.mode & 0o111) !== 0;
    } catch (_error) {
      return false;
    }
  }

  /**
   * Detect existing hook managers
   */
  detectHookManagers(): HookManager[] {
    const managers: HookManager[] = [];

    // Check for husky
    if (fs.existsSync('.husky')) {
      managers.push({
        name: 'husky',
        detected: true,
        configFile: '.husky',
        integration: 'Add smart-run lint to .husky/pre-commit',
      });
    }

    // Check for simple-git-hooks
    const packageJsonPath = 'package.json';
    if (fs.existsSync(packageJsonPath)) {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      if (packageJson['simple-git-hooks']) {
        managers.push({
          name: 'simple-git-hooks',
          detected: true,
          configFile: 'package.json',
          integration: 'Add smart-run lint to simple-git-hooks configuration',
        });
      }
    }

    // Check for lint-staged
    if (fs.existsSync(packageJsonPath)) {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      if (packageJson['lint-staged']) {
        managers.push({
          name: 'lint-staged',
          detected: true,
          configFile: 'package.json',
          integration: 'Add smart-run lint to lint-staged configuration',
        });
      }
    }

    return managers;
  }

  /**
   * Generate integration instructions for detected hook managers
   */
  generateIntegrationInstructions(): IntegrationInstruction[] {
    const managers = this.detectHookManagers();
    const instructions: IntegrationInstruction[] = [];

    if (managers.length === 0) {
      instructions.push({
        title: 'Direct Git Hooks',
        steps: [
          'Run: npx smart-run hooks install',
          'This will install pre-commit hook directly to .git/hooks/',
        ],
      });
    }

    managers.forEach((manager) => {
      switch (manager.name) {
        case 'husky':
          instructions.push({
            title: 'Husky Integration',
            steps: [
              'Add to .husky/pre-commit:',
              '  npx smart-run lint',
              'Or run: npx smart-run hooks husky',
            ],
          });
          break;

        case 'simple-git-hooks':
          instructions.push({
            title: 'Simple Git Hooks Integration',
            steps: [
              'Add to package.json:',
              '  "simple-git-hooks": {',
              '    "pre-commit": "npx smart-run lint"',
              '  }',
              'Or run: npx smart-run hooks simple-git-hooks',
            ],
          });
          break;

        case 'lint-staged':
          instructions.push({
            title: 'Lint-staged Integration',
            steps: [
              'Add to package.json:',
              '  "lint-staged": {',
              '    "package-meta.yaml": "npx smart-run lint"',
              '  }',
              'Or run: npx smart-run hooks lint-staged',
            ],
          });
          break;
      }
    });

    return instructions;
  }
}

/**
 * CLI interface for git hooks
 */
function cli(): void {
  const args = process.argv.slice(2);
  const command = args[0];
  const hooks = new GitHooks();

  switch (command) {
    case 'install':
      try {
        const results = hooks.install({
          hooks: args.slice(1).length > 0 ? args.slice(1) : ['pre-commit'],
          force: args.includes('--force'),
        });

        console.log('ðŸ”§ Git hooks installation results:');
        results.forEach((result) => {
          const icon = result.success ? 'âœ…' : 'âŒ';
          console.log(`${icon} ${result.hook}: ${result.message}`);
        });

        if (results.some((r) => r.success)) {
          console.log('\nðŸ’¡ Hooks installed! Configuration will be linted on git operations.');
        }
      } catch (error) {
        console.error(`âŒ Failed to install hooks: ${(error as Error).message}`);
        process.exit(1);
      }
      break;

    case 'uninstall':
      try {
        const results = hooks.uninstall({
          hooks: args.slice(1).length > 0 ? args.slice(1) : ['pre-commit'],
        });

        console.log('ðŸ”§ Git hooks uninstallation results:');
        results.forEach((result) => {
          const icon = result.success ? 'âœ…' : 'âŒ';
          console.log(`${icon} ${result.hook}: ${result.message}`);
        });
      } catch (error) {
        console.error(`âŒ Failed to uninstall hooks: ${(error as Error).message}`);
        process.exit(1);
      }
      break;

    case 'status': {
      const status = hooks.status();
      console.log('ðŸ“Š Git hooks status:');
      Object.entries(status).forEach(([hookName, hookStatus]) => {
        const icon = hookStatus.isSmartRunHook ? 'âœ…' : hookStatus.exists ? 'âš ï¸' : 'âŒ';
        const message = hookStatus.isSmartRunHook
          ? 'Smart-run hook installed'
          : hookStatus.exists
            ? 'Other hook exists'
            : 'Not installed';
        console.log(`${icon} ${hookName}: ${message}`);
      });
      break;
    }

    case 'detect': {
      const managers = hooks.detectHookManagers();
      const instructions = hooks.generateIntegrationInstructions();

      console.log('ðŸ” Detected hook managers:');
      if (managers.length === 0) {
        console.log('  No hook managers detected');
      } else {
        managers.forEach((manager) => {
          console.log(`  âœ… ${manager.name} (${manager.configFile})`);
        });
      }

      console.log('\nðŸ“‹ Integration instructions:');
      instructions.forEach((instruction) => {
        console.log(`\n${instruction.title}:`);
        instruction.steps.forEach((step) => {
          console.log(`  ${step}`);
        });
      });
      break;
    }

    default:
      console.log(`
ðŸ”§ Smart-run Git Hooks Integration

Usage: npx smart-run hooks <command>

Commands:
  install [hook...]   Install git hooks (default: pre-commit)
  uninstall [hook...] Uninstall git hooks
  status             Show hook installation status
  detect             Detect existing hook managers and show integration instructions

Options:
  --force            Force overwrite existing hooks

Examples:
  npx smart-run hooks install
  npx smart-run hooks install pre-commit pre-push
  npx smart-run hooks uninstall
  npx smart-run hooks status
  npx smart-run hooks detect
`);
  }
}

export { GitHooks, cli };

// Run CLI if called directly
if (require.main === module) {
  cli();
}
